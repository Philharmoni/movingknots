ls()
X1.grid
X2.grid
X1.grid <- seq(from = 0, to = 1, length.out = n)
Xq.grid
X1.grid
X1.grid <- seq(from = 0, to = 1, length.out = n)
Q
sourceDir("stable")
DGP(1000,1,  "interaction", TRUE)
sourceDir("stable")
DGP(1000,1,  "interaction", TRUE)
sourceDir("stable")
DGP(1000,1,  "interaction", TRUE)
sourceDir("stable")
DGP(1000,1,  "interaction", TRUE)
sourceDir("stable")
DGP(100,1,  "interaction", TRUE)
sourceDir("stable")
DGP(100,1,  "interaction", TRUE)
DGP(100,1,  "addtive", TRUE)
DGP(100,1,  "additive", TRUE)
DGP(100,1,  "radial", TRUE)
DGP(100,1,  "harmonic", TRUE)
sourceDir("stable")
DGP(100,1,  "harmonic", TRUE)
sourceDir("stable")
DGP(100,1,  "harmonic", TRUE)
sourceDir("stable")
DGP(100,1,  "harmonic", TRUE)
DGP(100,1,  "radial", TRUE)
sourceDir("stable")
DGP(100,1,  "radial", TRUE)
DGP(100,1,  "harmonic", TRUE)
DGP(100,1,  "additive", TRUE)
sourceDir("stable")
DGP(100,1,  "additive", TRUE)
sourceDir("stable")
DGP(100,1,  "additive", TRUE)
sourceDir("stable")
DGP(100,1,  "additive", TRUE)
sourceDir("stable")
sourceDir("stable")
sourceDir("stable")
sourceDir("stable")
sourceDir
source("aa.R")
sourceDir("stable")
ls()
list.files(Paths[i], pattern = "\\.[Rr]$", recursive = recursive)
aa  = list.files(Paths[i], pattern = "\\.[Rr]$", recursive = recursive)
aa
is.null(aa)
class(aa)
length(aa)
trace("source")
trace("source")
sourceDir("source")
sourceDir("source")
sourceDir("source")
sourceDir("source")
sourceDir("source")
sourceDir("source")
sourceDir("source")
getwd()
setwd("../")
sourceDir("source")
sourceDir("stable")
sourceDir("stable")
?trace
 tracingState(on = NULL)
 tracingState(on = NULL)
untrace("source")
sourceDir("stable")
sourceDir("stable")
sourceDir("stable")
sourceDir("stable")
sourceDir("stable")
q())
sourceDir("stable")
s
setwd("../")
getwd()
ls()
dir()
source("linear_setup.R")
where
browserText
browserText()
browserCondition
browserCondition()
getenv()
getNamespace()
where
where
source("linear_setup.R")
browserText()
browserCondition()
q()
Q
source("linear_setup.R")
ls()
n
nIter
source("linear_setup.R")
n
KStepNewton1
KStepNewton1
KStepNewton1
n
invHessOb.cur
invHessOb.cur
i
close.all()
source("linear_setup.R")
ls()
browserText()
n
Params_Name.cur
Params_Name.cur
Params_Name.cur
no.subset.cur
no.subset.cur
no.subsets.cur
ls()
n
i
i
param.cur.idx
param.cur.idx
n
n
KStepNewton1
KStepNewton1
n
HessObs.cur.prop
diag(HessObs.cur.prop)
1/diag(HessObs.cur.prop)
-1/diag(HessObs.cur.prop)
param.prop
param.prop
source("linear_setup.R")
n
browserText()
browserText()
browserText()
browserText()
browserText()
ls
())
ls()
n
KStepNewton1
KStepNewton1
n
source("linear_setup.R")
browserText()
browserText()
n
n
source("linear_setup.R")
n
n
source("linear_setup.R")
source("linear_setup.R")
close.all()
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
Q
close.all()
close.all()
source("linear_setup.R")
n
n
source("linear_setup.R")
close.all
close.all()
source("linear_setup.R")
traceback()
source("linear_setup.R")
source("linear_setup.R")
close.all()
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
close.all()
traceback()
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
k
n
caller
caller
gradObs.cur
gradObs.cur
hessObs.cur
hessObs.cur
solve(hessObs.cur)
-solve(hessObs.cur)
diag(-solve(hessObs.cur))
gradObs.cur
1*1
100*100
1/100*100
1/(100*100)
1/(10*10)
1/(1*1)
Q
source("linear_setup.R")
where
ls()
B
xi
ka0
mu0
priorArgs
ls()
hradient.out
hradient.out
gradient.out
ls()
B
priorArgs
 ka0 * solve(Sigma0) %*% (B-mu0)
 solve(Sigma0) %*% (B-mu0)
 solve(Sigma0)
  (B-mu0)
Q())
Q()
Q
q()
source("linear_setup.R")
setwd("..")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
traceback()
source("linear_setup.R")
close.all()
source("linear_setup.R")
ls()
iIter
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
iIter
iIter
source("linear_setup.R")
iIter
close.all()
source("linear_setup.R")
n
KStepNewton1
KStepNewton1
logjump.cur2prop
KStepNewton2
HessObs.prop.prop
HessObs.prop.prop
invHessObs.prop
invHessObs.prop
invHessObs.prop.prop
logjump.prop2cur
logjump.prop2cur
log.r
r
r
Q
source("linear_setup.R")
Q
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
OUT.accept.probs$ka
mean(OUT.accept.probs$ka)
source("linear_setup.R")
mean(OUT.accept.probs$ka)
source("linear_setup.R")
source("linear_setup.R")
mean(OUT.accept.probs$ka)
median(OUT.accept.probs$ka)
mean(OUT.accept.probs$ka)
source("linear_setup.R")
source("linear_setup.R")
mean(OUT.accept.probs$ka)
OUT.Params$ka
hist(OUT.Params$ka)
close.all()
hist(OUT.Params$ka)
source("linear_setup.R")
mean(OUT.accept.probs$ka)
hist(OUT.Params$ka)
mean(OUT.Params$ka)
mean(OUT.Params$ka)^2
n
50^2
source("linear_setup.R")
mean(OUT.Params$ka)^2
hist(OUT.Params$ka)
hist((OUT.Params$ka)^2)
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
iIter
close.all()
source("linear_setup.R")
iIter
close.all()
hist((OUT.Params$ka)^2
)
complete.cases
.path
.libPaths
.libPaths()
source("http://r.research.att.com/benchmarks/R-benchmark-25.R")
source("linear_setup.R")
mean(OUT.Params$ka)^2
hist((OUT.Params$ka)^2
)
mean((OUT.Params$ka)^2)
ka
source("linear_setup.R")
mean((OUT.Params$ka)^2)
mean(OUT.accept.probs$ka)^2
mean(OUT.accept.probs$ka)
source("linear_setup.R")
mean(OUT.accept.probs$ka)
mean(OUT.accept.probs$ka)^2
source("linear_setup.R")
mean(OUT.accept.probs$ka)
source("linear_setup.R")
mean(OUT.accept.probs$ka)
mean(OUT.accept.probs$ka)
mean(OUT.accept.probs$ka)
mean(OUT.accept.probs$ka)
mean(OUT.accept.probs$ka)
close.all()
source("linear_setup.R")
mean(OUT.accept.probs$ka)
median(OUT.accept.probs$ka)
source("linear_setup.R")
num.grad
grad.num
close.all()
source("linear_setup.R")
gradObs
grad.num
plot(grad.num$g, gradObs)
Q
source("linear_setup.R")
grad.num
gradObs
n
gradObs = gradObs.margi + gradObs.pri
gradObs
Q
source("linear_setup.R")
source("linear_setup.R")
n
gradObs = gradObs.margi + gradObs.pri
gradObs 
grad.num
Q
source("linear_setup.R")
grad.num
source("linear_setup.R")
source("linear_setup.R")
grad.num
source("linear_setup.R")
gradObs = gradObs.margi + gradObs.pri
gradOBs
gradObs
Q
source("linear_setup.R")
gradObs = gradObs.margi + gradObs.pri
gradObs
gradObs.cur
grad.num
grad.num$g
grad.num$g/gradObs
(grad.num$g-gradObs)/grad.num$g
Q
source("linear_setup.R")
OUT.accept.probs$ka
source("linear_setup.R")
source("linear_setup.R")
OUT.accept.probs$ka
source("linear_setup.R")
OUT.accept.probs$ka
source("linear_setup.R")
OUT.accept.probs$ka
source("linear_setup.R")
OUT.accept.probs$ka
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
source("linear_setup.R")
iIter
OUT.accept.probs$ka
OUT.accept.probs$xi
source("linear_setup.R")
iIter
OUT.accept.probs$xi
OUT.accept.probs$ka
source("linear_setup.R")
OUT.accept.probs$ka
Q
source("linear_setup.R")
OUT.accept.probs$ka
source("linear_setup.R")
n
KStepNewton1
param.cur
prarm.prop
prarm.prop
param.prop
-invHessObs.cur.prop
logjump.cur2prop
logjump.cur2prop
exp(logjump.cur2prop)
param.prop.prop
param.prop.prop
logjump.prop.2cur
logjump.prop.2cur
logjump.prop2cur
caller.prop
caller.prop
logpost.prop
logpost.cur
logpost.cur
log.r
log.r
exp(r)
exp(log.r)
logpost.prop - logpost.cur + logjump.prop2cur - logjump.cur2prop
logpost.prop 
logpost.cur
logjump.prop2cur
 logjump.cur2prop
Q
source("linear_setup.R")
n
KStepNewton1
log.r
r
r
Q
source("linear_setup.R")
OUT.accept.probs
source("linear_setup.R")
OUT.accept.probs
source("linear_setup.R")
OUT.accept.probs
OUT.accept.probs$ka
Q
setwd("..")
source("linear_setup.R")
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
setwd("..")
system.time(source("linear_setup.R"))
setwd("..")
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
xi.desi
OUT.Params.mode
OUT.Params
OUT.Params[["xi"]]
lapply(OUT.Params,
                          function(x) apply(x[, , -(0:num.burn.in),drop=FALSE], c(1, 2),
                                            mean))
num.burn.in
apply(Params[["xi"]], c(1, 2), mean)
apply(Params[["xi"]], c(1, 2), median)
lapply(OUT.Params,
                          function(x) apply(x[, , -(0:num.burn.in)], c(1, 2),
a <- marix(rnorm(10))
system.time(source("linear_setup.R"))
OUT.Params.mode
xi.desi
close.all()
system.time(source("linear_setup.R"))
OUT.Params.mode
xi.desi
system.time(source("linear_setup.R"))
OUT.Params.mode
xi.desi
OUT.Params.mode
system.time(source("linear_setup.R"))
xi.desi
OUT.Params.mode
close.all()
system.time(source("linear_setup.R"))
xi.desi
OUT.Params.mode
system.time(source("linear_setup.R"))
OUT.Params.mode
xi.desi
plot(xi.desi)
close.all()
plot(xi.desi)
points(OUT.Params.mode$xi)
plot(xi.desi, col = "red", xlim = c(-2, 2), ylim = c(-2, 2))
plot(xi.desi, col = "red", xlim = c(-0.5, 1.5), ylim = c(-0.5, 1.5))
points(OUT.Params.mode$xi)
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
xi
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
a <- matrix(rnorm(36), 6)
a
a[, 1] <- a[, 2]
a
solve(crossprod(a))
is.single(5.0)
is.single("Feng Li")
solve(crossprod(a))
solve(crossprod(a))
solve(crossprod(a))
system.time(source("linear_setup.R"))
points(OUT.Params.mode$xi)
points(xi.desi)
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
points(OUT.Params.mode$xi)
points(xi.desi, col = "red")
close.all()
system.time(source("linear_setup.R"))
traceback()
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
traceback()
system.time(source("linear_setup.R"))
system.time(source("linear_setup.R"))
OUT.Params.mode
points(xi.desi, col = "blue")
points(OUT.Params.mode$xi, col = "red")
system.time(source("linear_setup.R"))
points(OUT.Params.mode$xi, col = "red")
points(xi.desi, col = "blue")
warnings()
Q
setwd("..")
source("linear.singleshrinkage_setup.R")
ls()
crossvalid.struc
source("linear.singleshrinkage_setup.R")
dev.copy2pdf()
ls()
crossvalid.struc
crossvalid.struc
crossvalid.struc[["pred"]]
length(crossvalid.struc[["pred"]])
c("B", "Sigma") %in% c("B",  "Sigma", "S")
c("B", "Sigma") %in% c("B",  "Sigma", "S")
all(c("B", "Sigma") %in% c("B",  "Sigma", "S"))
source("linear.singleshrinkage_setup.R")
crossvalid.struc
nCross
OUT.Params
OUT.Params[["xi"]]
(OUT.Params[["xi"]])
dim(OUT.Params[["xi"]])
a  =  dim(OUT.Params[["xi"]])
a
a[-2]
a[2]
a  =  dim(OUT.Params[["xi"]])
a
a
max(a)
lapply(OUT.Params, c(1, 2, 3))
lapply(OUT.Params, function(x) x[, , 1, 3])
lapply(OUT.Params, function(x) x[, , 1, 3, drop = FALSE])
lapply(OUT.Params, apply function(x) x[, , 1, 3, drop = FALSE])
lapply(OUT.Params, apply,  function(x) x[, , 1, 3, drop = FALSE])
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE]))
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE]))
lapply(OUT.Params, function(x) (x[, , 1, 3, drop = FALSE]))
lapply(OUT.Params, function(x) (x[, , 1, 3, drop = FALSE]))
lapply(OUT.Params, function(x) (x[, , 1, 3, drop = FALSE]))[["xi"]]
dim(lapply(OUT.Params, function(x) (x[, , 1, 3, drop = FALSE]))[["xi"]])
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE]))
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE], c(1, 2, 4)))
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE], c(1, 2, 4)), x)
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE], c(1, 2, 4), x))
lapply(OUT.Params, function(x) (x[, , 1, 3, drop = FALSE]))
lapply(OUT.Params, function(x) (x[, , 1, 3]))
lapply(OUT.Params, function(x) (x[, , 1, 3]))
lapply(OUT.Params, function(x) (x[, , 1, 3, F]))
lapply(OUT.Params, function(x) (x[, , 1, 3, drop = F]))
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE]))
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE], c(1, 2, 4), mean))
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE], c(1, 2), mean))
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE], c(1, 2), mean))
lapply(OUT.Params, function(x) apply(x[, , 1, 3, drop = FALSE], c(1, 2), mean))
log.post.fun
ls()
logpost.fun.name
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), mean))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(4), mean))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), mean))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), x))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), [))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), "[]"))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), "["))
Y
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), "["))
lapply(OUT.Params, c(1, 2), "["))
lapply(OUT.Params, c(1, 2), "[")
lapply(OUT.Params, "[")
lapply(OUT.Params, "[", c(1, 2))
lapply(OUT.Params, "[", c(1, 2, 3, 4))
lapply(OUT.Params, "[", c(1, 2, 3, 1))
lapply(OUT.Params, "[", c(, , 3, 1))
lapply(OUT.Params, function(x) (x[, , 1, 3, drop  =  F]))
lapply(OUT.Params, function(x) (x[, , 1, 3]))
lapply(OUT.Params, function(x) (x[, , 1, 3]))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), "["))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2)))
lapply(OUT.Params, function(x) apply(x[, , 1, 1, drop = FALSE], c(1, 2), "["))
traceback()
n
n
print(n)
Y
nIter
num.burn.in
nUsed
nUsed
nCross
ls()
LPDS
LPDS
Q
a <- matrix(1:24, 6)
a
mapply(, FUN = function(x, centers) kmeans(x)$centers, centers = )
sourceDir("utils", T)
array2list
array2list
a
array2list(a, 2)
a
a <- c(1, 2, 3)
as.list(a)
traceback()
n
n
idx
idx
out
nknots
Q
traceback()
n
out
out
a
a$thinplate.s
a$thinplate.a
as.vector(a$thinplate.a)
unlist(a$thinplate.a)
a
traceback()
traceback()
nIter
iIter
iSub
iPar
 Params.sub.struc
n
which.sub
n
Q
hessMethods

for(iCross in 1:nCross) # loop over subsets of data. TODO: Parallel Computing?
  {
    ## Training sample
    Y.iCross <- Y[crossvalid.struc$training[[iCross]], , drop = FALSE]
    x.iCross <- x[crossvalid.struc$training[[iCross]], , drop = FALSE]
    
    for(iIter in 1:nIter) # loop nIter times
      {
        for (iPar in Params4Gibbs) # only update xi,  K and Sigma
          {
            which.sub <- 0
            for(iSub in Params.sub.struc[[iPar]]) # update subsets
              {
                which.sub <- which.sub+1
                param.cur <- matrix(Params[[iPar]][iSub])
                out.iSub <- MHPropMain(param.cur = param.cur, gradhess.fun.name =
                                       gradhess.fun.name, logpost.fun.name =
                                       logpost.fun.name, nNewtonStep =
                                       nNewtonStep[[iPar]],Params = Params, hessMethod =
                                       hessMethods[[iPar]], Y = Y.iCross, x = x.iCross,
                                       callParam = list(id = iPar, subset = iSub),
                                       splineArgs = splineArgs, priorArgs = priorArgs,
                                       prop.df = MH.prop.df[[iPar]], Params_Transform =
                                       Params_Transform, propMethod =
                                       propMethods[[iPar]])    
                
                ## Update the parameters in the parameters list.
                Params[[iPar]][iSub] <- out.iSub$param.out
                
                ## Save the acceptance probability
                OUT.accept.probs[[iPar]][which.sub, iIter, iCross] <- out.iSub$accept.prob
                
              } # for(i in 1:no.subsets.cur)
            
            ## Save the updated paramters for current iteration.
            OUT.Params[[iPar]][,  , iIter, iCross] <- Params[[iPar]]
          } # for (iPar in Params4Gibbs)
        
        ## Track the iterations
        if(track.MCMC) { MCMC.trajectory(interval = .10) }        
      }
  } # for(iCross in 1:nCross)

traceabck()
traceback()
for(iCross in 1:nCross) # loop over subsets of data. TODO: Parallel Computing?
  {
    ## Training sample
    Y.iCross <- Y[crossvalid.struc$training[[iCross]], , drop = FALSE]
    x.iCross <- x[crossvalid.struc$training[[iCross]], , drop = FALSE]
    
    for(iIter in 1:nIter) # loop nIter times
      {
        for (iPar in Params4Gibbs) # only update xi,  K and Sigma
          {
            which.sub <- 0
            for(iSub in Params.sub.struc[[iPar]]) # update subsets
              {
                which.sub <- which.sub+1
                param.cur <- matrix(Params[[iPar]][iSub])
                out.iSub <- MHPropMain(param.cur = param.cur, gradhess.fun.name =
                                       gradhess.fun.name, logpost.fun.name =
                                       logpost.fun.name, nNewtonStep =
                                       nNewtonStep[[iPar]],Params = Params, hessMethod =
                                       hessMethods[[iPar]], Y = Y.iCross, x = x.iCross,
                                       callParam = list(id = iPar, subset = iSub),
                                       splineArgs = splineArgs, priorArgs = priorArgs,
                                       prop.df = MH.prop.df[[iPar]], Params_Transform =
                                       Params_Transform, propMethod =
                                       propMethods[[iPar]])    
                
                ## Update the parameters in the parameters list.
                Params[[iPar]][iSub] <- out.iSub$param.out
                
                ## Save the acceptance probability
                OUT.accept.probs[[iPar]][which.sub, iIter, iCross] <- out.iSub$accept.prob
                
              } # for(i in 1:no.subsets.cur)
            
            ## Save the updated paramters for current iteration.
            OUT.Params[[iPar]][,  , iIter, iCross] <- Params[[iPar]]
          } # for (iPar in Params4Gibbs)
        
        ## Track the iterations
        if(track.MCMC) { MCMC.trajectory(interval = .10) }        
      }
  } # for(iCross in 1:nCross)

traceback()
MH.prop.df
ls()
prop.df
Y
ls()
callParam
x
ls()
priorArgs
ls()
param.cur
hessMethod
gradhess.fun.name
Params_Transform
splineArgs
Q

cat("Updating Knots Shrinkages and Covariance >>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n")

for(iCross in 1:nCross) # loop over subsets of data. TODO: Parallel Computing?
  {
    ## Training sample
    Y.iCross <- Y[crossvalid.struc$training[[iCross]], , drop = FALSE]
    x.iCross <- x[crossvalid.struc$training[[iCross]], , drop = FALSE]
    
    for(iIter in 1:nIter) # loop nIter times
      {
        for (iPar in Params4Gibbs) # only update xi,  K and Sigma
          {
            which.sub <- 0
            for(iSub in Params.sub.struc[[iPar]]) # update subsets
              {
                which.sub <- which.sub+1
                param.cur <- matrix(Params[[iPar]][iSub])
                out.iSub <- MHPropMain(param.cur = param.cur, gradhess.fun.name =
                                       gradhess.fun.name, logpost.fun.name =
                                       logpost.fun.name, nNewtonStep =
                                       nNewtonStep[[iPar]],Params = Params, hessMethod =
                                       hessMethods[[iPar]], Y = Y.iCross, x = x.iCross,
                                       callParam = list(id = iPar, subset = iSub),
                                       splineArgs = splineArgs, priorArgs = priorArgs,
                                       prop.df = MH.prop.df[[iPar]], Params_Transform =
                                       Params_Transform, propMethod =
                                       propMethods[[iPar]])    
                
                ## Update the parameters in the parameters list.
                Params[[iPar]][iSub] <- out.iSub$param.out
                
                ## Save the acceptance probability
                OUT.accept.probs[[iPar]][which.sub, iIter, iCross] <- out.iSub$accept.prob
                
              } # for(i in 1:no.subsets.cur)
            
            ## Save the updated paramters for current iteration.
            OUT.Params[[iPar]][,  , iIter, iCross] <- Params[[iPar]]
          } # for (iPar in Params4Gibbs)
        
        ## Track the iterations
        if(track.MCMC) { MCMC.trajectory(interval = .10) }        
      }
  } # for(iCross in 1:nCross)

traceback()
nNewtonStep
ls()
nNewtonStep
prop.df
Q
source("examples/linear_setup.R")
prop.df
param.cur
gradhess.fun.name
logpost.fun.name
ls()
hessMethod
nNewtonStep
iPar
nNewtonStep[[iPar]]
nNewtonStep
Q
source("examples/linear_setup.R")
nNewtonSteps
nNewtonStep
nNewtonSteps[[iPar]]
nNewtonStep
source("examples/linear_setup.R")
ls()
nNewtonSteps
nNewtonStep
Q
source("examples/linear_setup.R")
ls()
callParam
gradhess.fun.name
logpost.fun.name
Params
ls()
nNewtonSteps
nNewtonStep
param.cur
Params_Transform
priorArgs
ls()
propMethods
x.iCross
ls()
Y.iCross
n
Q
source("examples/linear_setup.R")
ls()
Q
source("examples/linear_setup.R")
length(OUT.Params[[iPar]])
dim(OUT.Params[[iPar]])
iPar
out.iSub
exp(2.8)
source("examples/linear_setup.R")
source("examples/linear_setup.R")
traceback()
source("examples/linear_setup.R")
source("examples/linear_setup.R")
source("examples/linear_setup.R")
pnorm
?pnorm
ls()
return()
a <- function(x) retrun()
a
a(2)
a <- function(x) return()
a
a(2)
progresbar
getwd()
setwd("../../Projects/")
source("simul_s_moving_2.R")
traceback()
source("simul_s_moving_2.R")
source("simul_s_moving_2.R")
source("simul_s_moving_2.R")
traceback()
Data.gen
Data.gen[["SurfaceMean"]]
names(Data.gen)
source("simul_s_moving_2.R")
MovingKnots_Dignosis <- FitDiagnosis(x, Y, OUT.Params, Data.gen, logpost.fun.name,
                                     splineArgs, Params_Transform, crossvalid.struc,
                                     burn.in, criterion = c("LOSS", "KL", "L2"))   

source("simul_s_moving_2.R")
source("simul_s_moving_2.R")
MovingKnots_Dignosis
source("simul_s_moving_2.R")
MovingKnots_Dignosis
source("simul_s_moving_2.R");MovingKnots_Dignosis
source("simul_s_moving_2.R");MovingKnots_Dignosis
Data.gen$B
OUT.Params.mode$coefficients
source("simul_s_moving_2.R");MovingKnots_Dignosis
source("simul_s_moving_2.R");MovingKnots_Dignosis
source("simul_s_moving_2.R");MovingKnots_Dignosis
source("simul_s_moving_2.R");MovingKnots_Dignosis
n <- 10; a <- matrix(rnorm(5*n), n);hist(a)
n <- 10; a <- matrix(rnorm(5*n), n);boxplot(a)
n <- 20; a <- matrix(rnorm(5*n), n);boxplot(a)
5
5/2
is.integer(5/2)
is.integer(6/2)
is.integer(6%%2)
6%%2
5%%2
7%%2
7%%2 == 1
source("simul_s_moving_2.R")
OUT.LOSS
as.matrix(OUT.LOSS)
as.matrix(OUT.LOSS, 2)
as.matrix(OUT.LOSS, 2, 2)
matrix(OUT.LOSS, 2)
c <- t(matrix(OUT.LOSS, 2))
c
c[, 2]/c[1]
c[, 2]/c[, 1]
c[, 2]
c <- t(matrix(OUT.LOSS, 2))
class(c)
as.vector(c)
dd <- as.vector(c)
dd[, 2]/dd[, 1]
dd[, 1]
d[c(3, 4)]
dd[c(3, 4)]
dd[c(3, 4)]/dd[c(1, 2)]
dd[3]/dd[1]
unlist(dd)
matrix(unlist(dd), 2)
d <- matrix(unlist(dd), 2)
dd
d
d[, 2]/d[, 1]
log(d[, 2]/d[, 1])
  cat(paste("Running: \"", ModelDescription, "_rep(", iRep, ")\" @",Sys.time(),".\n\n", sep = ""))

q())
q()
